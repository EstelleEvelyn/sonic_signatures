<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Plotting Z-Scores</title>
    <meta name="description" content="">
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <style type="text/css">
    body {
        font: 10px sans-serif;
    }
    .axis path,
    .axis line {
        fill: none;
        stroke: #000;
        shape-rendering: crispEdges;
    }
    /*.x.axis path {
        display: none;
    }*/
    .line {
        fill: none;
        stroke: steelblue;
        stroke-width: 1.5px;
    }
    </style>
</head>

<body>
  <div>
    Sort by
    <form id="sort", onchange = "sortOrder()"> <br>
      <input id = 'psort' type="radio" name="role" value="protag" checked> Protagonist<br>
      <input id = 'asort' type="radio" name="role" value="antag"> Antagonist<br>
      <input id = 'fsort' type="radio" name="role" value="fool"> Fool
    </form>
  </div>
  <div>
    Show
    <form id = "show", onchange = "loadData()">  <br>
      <input type = "checkbox" value = "protag" checked> Protagonist<br>
      <input type = "checkbox" value = "antag" checked> Antagonist<br>
      <input type = "checkbox" value = "fool" checked> Fool
    </form>
  </div>
  <div>
    Compare<br>
    <select id="Play", onchange="onSelect()">
      <option value="default">Play</option>
      <option value="AWW">All's Well That Ends Well</option>
      <option value="Ant">Antony and Cleopatra</option>
      <option value="AYL">As You Like It</option>
      <option value="Err">The Comedy of Errors</option>
      <option value="Cor">Coriolanus</option>
      <option value="Cym">Cymbeline</option>
      <option value="Ham">Hamlet</option>
      <option value="1H4">Henry IV, Part 1</option>
      <option value="2H4">Henry IV, Part 2</option>
      <option value="H5">Henry V</option>
      <option value="1H6">Henry VI, Part 1</option>
      <option value="2H6">Henry VI, Part 2</option>
      <option value="3H6">Henry VI, Part 3</option>
      <option value="H8">Henry VIII</option>
      <option value="JC">Julius Caesar</option>
      <option value="Jn">King John</option>
      <option value="Lr">King Lear</option>
      <option value="LLL">Love's Labor's Lost</option>
      <option value="Mac">Macbeth</option>
      <option value="MM">Measure for Measure</option>
      <option value="MV">The Merchant of Venice</option>
      <option value="Wiv">The Merry Wives of Windsor</option>
      <option value="MND">A Midsummer Night's Dream</option>
      <option value="Ado">Much Ado About Nothing</option>
      <option value="Oth">Othello</option>
      <option value="Per">Pericles</option>
      <option value="R2">Richard II</option>
      <option value="R3">Richard III</option>
      <option value="Rom">Romeo and Juliet</option>
      <option value="Shr">The Taming of the Shrew</option>
      <option value="Tmp">The Tempest</option>
      <option value="Tim">Timon of Athens</option>
      <option value="Tit">Titus Andronicus</option>
      <option value="Tro">Troilus and Cressida</option>
      <option value="TN">Twelfth Night</option>
      <option value="TGV">The Two Gentlemen of Verona</option>
      <option value="TNK">The Two Noble Kinsmen</option>
      <option value="WT">The Winter's Tale</option>
    </select>

    <select id="Character", onchange ="compare()">
      <option value = "default">Character</option>
    </select>

  </div>
</body>

  <script type = "text/javascript">
    function onSelect() {
      d3.select('#Character')
        .selectAll('option')
        .remove();

      var play = document.getElementById('Play').value
      var dataURL = '/options/' + play
      d3.json(dataURL, function(error, data) {
        var data = data;
        if (data[0] != 'Character') {
          d3.select('#Character')
            .selectAll('option')
            .data(data)
            .enter()
            .append('option')
            .text(function(d) { return d; })
            .property('value', function(d) {
              return play + "_" + d;
            })
        }
        else {
          d3.select('#Character')
            .append('option')
            .text('Character')
            .property('value', 'default')
          compare();
        }
      });
    }

    var svgWidth = 400;
    var svgHeight = 3200;
    var buffer = 10;

    var svg = d3.select("body").append("svg")
                .attr('width', svgWidth)
                .attr('height', svgHeight)


    var pivotLine = d3.select('svg')
                      .append('line')
                      .attr('x1', svgWidth / 2)
                      .attr('x2', svgWidth / 2)
                      .attr('y1', svgHeight - buffer)
                      .attr('y2', buffer)
                      .style('stroke', 'black')

    var features = ['fricative', 'affricate', 'glide', 'nasal', 'liquid',
            'stop', 'glottal', 'linguaalveolar', 'linguapalatal', 'labiodental',
            'bilabial', 'linguavelar','linguadental', 'voiced', 'voiceless',
            'sibilant', 'nonsibilant', 'sonorant', 'nonsonorant', 'coronal',
            'noncoronal', 'monophthong', 'diphthong', 'central', 'front', 'back',
            'tense', 'lax', 'rounded', 'unrounded']

    var segment = (svgHeight - 2*buffer) / (features.length)


    var topLine = d3.select('svg')
                        .selectAll('line')
                        .data(features)
                        .enter()
                        .append('line')
                        .attr('x1', 0)
                        .attr('x2', svgWidth)
                        .attr('y1', function(d, i) { return buffer + (segment * i); })
                        .attr('y2', function(d, i) { return buffer + (segment * i); })
                        .style('stroke', 'black');

    var pivotLine = d3.select('svg')
                        .append('line')
                        .attr('x1', svgWidth / 2)
                        .attr('x2', svgWidth / 2)
                        .attr('y1', svgHeight - buffer)
                        .attr('y2', buffer)
                        .style('stroke', 'black')


    function onLoad() {

      d3.selectAll('g').remove()
    svg.selectAll('text').remove()

      var featureGroup = d3.select('svg')
                          .selectAll('g')
                          .data(features)
                          .enter()
                          .append('g')
                          .property('id', function(d) {return d; })
                          // .attr('y', function(d, i) { return buffer + (segment * i)/*TODO determine how this should scale*/ ; })
                          // .attr('x', function(d, i) { return 0 /*TODO determine if/how this should scale*/; })
                          // .attr('width', svgWidth)
                          // .attr('height', segment)
                          // .style('fill', 'white');

      var boxLabel = d3.select('svg')
                          .selectAll('text')
                          .data(features)
                          .enter()
                          .append('text')
                          .text(function(d) { return d; })
                          .attr('y', function(d, i) { return buffer + (segment * i) + 10; })
                          .attr('x', function(d, i) { return 5; });

      loadData();
    }

    function loadData() {

      var dataURL = '/feature_data'
      d3.json(dataURL, function(error, data){
        var zdata = data

        for (var i = 0; i < features.length; i++) {
          var bars =   d3.select('#'+features[i])
                          .selectAll('rect')
                          .data(obj = zdata[features[i]])
                          .enter()
                          .append('rect')
                          .property('id', function(d, j) {
                            if (j == 0) {
                              return features[i] + '_prot';
                            } else if (j == 1) {
                              return features[i] + '_ant';
                            } else {
                              return features[i] + '_fool';
                            }
                          })
                          .attr('x', function (d) {
                              if (d > 0) {
                                return pos = svgWidth / 2;
                              } else {
                                norm = 1+d;
                                return pos = svgWidth / 2 * (norm);
                              }
                            })
                          .attr('y', function(d, j) { return i * segment + j * segment / 3 + buffer * 1.25; })
                          .attr('width', function(d) {return Math.abs(d * svgWidth / 2); })
                          .attr('height', segment / 3 - buffer / 2)
                          .attr('class', function (d, j) {
                            if (j == 0) {
                              return 'prot';
                            } else if (j == 1) {
                              return 'ant';
                            } else {
                              return 'fool';
                            }
                          })
                          .style('fill', function(d, j) {
                            if (j == 0) {
                              return '#E68BFF';
                            } else if (j == 1) {
                              return '#3ECC97';
                            } else {
                              return '#FFDB83';
                            }
                          })
            vals = document.getElementById('show').elements
            if (!vals[0].checked){
              d3.selectAll('.prot').remove()
            } if (!vals[1].checked){
              d3.selectAll('.ant').remove()
            } if (!vals[2].checked){
              d3.selectAll('.fool').remove()
            }
        }
      })
    }

    onLoad();

    function compare() {

      var dataURL = '/compare/'+document.getElementById('Character').value
      d3.json(dataURL, function(error, data){

        if (data.length != 0) {
            var feat_data = data['features']
            var phon_data = data['phonemes']
        }

        for (var i = 0; i < features.length; i++) {
          d3.select('#'+features[i]).selectAll('line').remove();

          if (data.length != 0){
            var feat_line = d3.select('#'+features[i])
                          .append('line')
                          .property('id', document.getElementById('Character'.value))
                          .attr('x1', function() { return svgWidth / 2* (1 + feat_data[features[i]])})
                          .attr('x2', function() { return svgWidth / 2 * (1 + feat_data[features[i]])})
                          .attr('y1',  buffer + (segment * i))
                          .attr('y2', buffer + (segment * (i + 1)))
                          .style('stroke', 'black')
          }
        }
      })
    }

    function sortOrder() {
      var dataURL = '/feature_data'

      d3.json(dataURL, function(error, data){
        var unordered_data = data
        var new_dat = []
        for (var i = 0; i < features.length; i++) {
          var currFeat = features[i]
          var z_vals = unordered_data[currFeat]
          var new_tuple


          if (document.getElementById('psort').checked) {
              new_tuple = [z_vals[0],  currFeat]

          } else if (document.getElementById('asort').checked) {
              new_tuple = [z_vals[1], currFeat]

          } else {
              new_tuple = [z_vals[2], currFeat]
          }
          new_dat.push(new_tuple)
        }

        new_dat.sort(sortFunction);
        new_dat

        function sortFunction(a, b) {
            if (a[0] === b[0]) {
                return 0;
            }
            else {
                return (a[0] < b[0]) ? -1 : 1;
            }
        }
        var new_features = []
        for (var j = new_dat.length - 1; j >= 0; j--) {
          new_features.push(new_dat[j][1])
        }
        features = new_features
        onLoad();
      })
    }

  </script>

</html>
